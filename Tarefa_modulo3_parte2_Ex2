import numpy as np
1) Alturas
i. No trecho de cÃ³digo abaixo, crie um ndarray chamado altura_em_centimetros transformando a lista lista_de_alturas em um ndarray do numpy com a funÃ§Ã£o np.array()
ii. Crie um outro objeto altura_em_metros, com os valores de altura_em_centimetros convertidos para metros.

lista_de_centimetros = list(range(170, 190, 5))
lista_de_centimetros
â€‹
altura_em_centimetros = np.array(lista_de_centimetros)
â€‹
altura_em_metros = altura_em_centimetros / 100
altura_em_centimetros 
array([170, 175, 180, 185])
altura_em_metros 
array([1.7 , 1.75, 1.8 , 1.85])
2) IMC
i. Considere que pesos em Kg dessas pessoas, na mesma ortem, estÃ£o na lista pesos lista_pesos = [70, 75, 80, 85]. Crie um ndarray chamado pesos com a funÃ§Ã£o np.array() que contenha esses valores.
ii. Utilizando o objeto que contÃ©m as alturas em metros e esse objeto que contÃ©m os respectivos pesos em quilos, calcule o IMC desses indivÃ­duos utilizando a aritmÃ©tica de arrays e guarde os resultados em um objeto chamado imc.

lista_pesos = [70, 75, 80, 85]
lista_pesos
# seu cÃ³digo aqui
pesos = np.array(lista_pesos)
# calcule o IMC dessas pessoas
imc = pesos / (altura_em_metros ** 2)
3) Endividamento
CÃ¡lculos de novas variÃ¡veis como endividamento total e comprometimento de renda sÃ£o essenciais para a construÃ§Ã£o de modelos financeiros em ciÃªncia de dados. Ãreas nÃ£o financeiras terÃ£o cÃ¡lculos semelhantes tambÃ©m. Vamos praticar:

Considere que o seguinte ndarray contÃ©m os dados de 4 pessoas, total a ser pago a emprÃ©stimos mensalmente e renda familiar:

custo fixo	dÃ­vida financeira	renda familiar
3000	1000	6000
2500	2500	5500
1000	3000	7000
10000	5000	16000
i. Transforme a lista de listas dados_financeiros no ndarray nd_financeiros.

dados_financeiros[[3000, 2500, 1000, 10000],[1000, 2500, 3000, 5000],[6000, 5500, 7000, 16000]]

ii. Utilize o mÃ©todo .transpose e certifique-se de que esse ndarray tenha uma linha por indivÃ­duo e uma coluna por informaÃ§Ã£o. Utilizando a indexaÃ§Ã£o do numpy, imprima no output a segunda linha do array, depois a segunda coluna.

iii. Pratique aritmÃ©tica com nearrays e calcule o endividamento total como:
ğ‘’ğ‘›ğ‘‘ğ‘–ğ‘£ğ‘–ğ‘‘ğ‘ğ‘šğ‘’ğ‘›ğ‘¡ğ‘œğ‘¡ğ‘œğ‘¡ğ‘ğ‘™=ğ‘ğ‘¢ğ‘ ğ‘¡ğ‘œğ‘“ğ‘–ğ‘¥ğ‘œ+ğ‘‘Ã­ğ‘£ğ‘–ğ‘‘ğ‘ğ‘“ğ‘–ğ‘›ğ‘ğ‘›ğ‘ğ‘’ğ‘–ğ‘Ÿğ‘ğ‘Ÿğ‘’ğ‘›ğ‘‘ğ‘ğ‘“ğ‘ğ‘šğ‘–ğ‘™ğ‘–ğ‘ğ‘Ÿ
Guarde os resultados em uma variÃ¡vel chamada endividamento_total e verifique os resultados imprimindo o conteÃºdo dessa variÃ¡vel no output.

iv. Considere que hÃ¡ um erro de digitaÃ§Ã£o que precisa ser corrigido: 3o indivÃ­duo na verdade nÃ£o possui renda familiar de R$7.000,00, mas sim R$ 10.000,00. Corrija esse valor e refaÃ§a os cÃ¡lculos.

n
# lista dados_financeiros
dados_financeiros = [[3000, 2500, 1000, 10000],[1000, 2500, 3000, 5000],[6000, 5500, 7000, 16000]]
dados_financeiros
#i) transforme essa lista em um ndarray
nd_financeiros = np.array(dados_financeiros)
nd_financeiros
array([[ 3000,  2500,  1000, 10000],
       [ 1000,  2500,  3000,  5000],
       [ 6000,  5500,  7000, 16000]])
# ii) 
np.array(nd_financeiros).transpose()
â€‹
print(nd_financeiros[1])
â€‹
print("\nSegunda coluna:")
â€‹
print(nd_financeiros[:, 1])
[1000 2500 3000 5000]

Segunda coluna:
[2500 2500 5500]
# iii) Calcule o endividamento total
custo_fixo = nd_financeiros[0]
divida_financeira = nd_financeiros[1]
renda_familiar = nd_financeiros[2]
â€‹
endividamento_total = (custo_fixo + divida_financeira) / renda_familiar
â€‹
print("Endividamento total de cada indivÃ­duo:")
print(endividamento_total)
Endividamento total de cada indivÃ­duo:
[0.66666667 0.90909091 0.57142857 0.9375    ]
# iv) corrigindo um valor especÃ­fico
nd_financeiros[2, 2] = 10000
â€‹
custo_fixo = nd_financeiros[0]
divida_financeira = nd_financeiros[1]
renda_familiar = nd_financeiros[2]
â€‹
endividamento_total = (custo_fixo + divida_financeira) / renda_familiar
â€‹
print("Endividamento total de cada indivÃ­duo apÃ³s a modificaÃ§Ã£o:")
â€‹
print(endividamento_total)
Endividamento total de cada indivÃ­duo apÃ³s a modificaÃ§Ã£o:
[0.66666667 0.90909091 0.4        0.9375    ]
4) Ã‰ muito comum precisarmos identificar valores especiais e darmos tratamento a eles quer seja alterando-os quer seja descartando-os.
O trecho de cÃ³digo abaixo gera um ndarray com nÃºmeros pseudo aleatÃ³rios. Considere que para efeitos do estudo que virÃ¡, devemos desconsiderar valores iguais a zero. Sendo assim:

i) crie um objeto bool_zero que traga uma sequencia de booleanos do mesmo tamanho que o objeto poi, e que vale True quando o valor de poi Ã© zero, e False caso contrÃ¡rio.

ii) Conte quantos valores zero existem. Lembre-se de que no final das contas, True vale 1 para o Python, e False vale zero, entÃ£o uma boa dica seria usar a funÃ§Ã£o sum().

iii) Utilize a indexaÃ§Ã£o booleana que vocÃª aprendeu para criar uma variÃ¡vel poi_nao_zero que aponta para os elementos de poi diferentes de zero. Dica: vocÃª vai pode inverter os elementos do objeto que criou em ii) ou escrever a comparaÃ§Ã£o adequada.

# objeto poi - obs: o comando np.random.seed(1234) garante que o mesmo resultado serÃ¡ gerado sempre
np.random.seed(1234)
poi = np.random.poisson(3, 100)
poi
array([3, 3, 6, 2, 4, 5, 4, 4, 2, 0, 3, 3, 2, 8, 2, 3, 3, 3, 0, 4, 4, 2,
       6, 6, 0, 3, 4, 3, 5, 2, 1, 3, 2, 2, 3, 2, 4, 4, 5, 7, 3, 5, 3, 3,
       2, 2, 3, 6, 2, 2, 4, 3, 5, 2, 5, 3, 0, 2, 1, 1, 4, 4, 4, 6, 2, 4,
       1, 2, 5, 5, 3, 4, 1, 4, 1, 1, 7, 1, 2, 1, 3, 7, 0, 4, 4, 0, 6, 1,
       3, 4, 2, 5, 4, 5, 5, 3, 4, 6, 8, 2])
# i) crie o objeto bool_zero atravÃ©s do operador ==
â€‹
bool_zero = (poi == 0)
â€‹
bool_zero
â€‹
print(bool_zero)
[False False False False False False False False False  True False False
 False False False False False False  True False False False False False
  True False False False False False False False False False False False
 False False False False False False False False False False False False
 False False False False False False False False  True False False False
 False False False False False False False False False False False False
 False False False False False False False False False False  True False
 False  True False False False False False False False False False False
 False False False False]
# ii) Conte a quantidade de zeros (ou some os elementos de bool_zero)
â€‹
num_zeros = np.sum(bool_zero)
â€‹
print("NÃºmero de valores zero:", num_zeros)
NÃºmero de valores zero: 6
# iii) utilize a indexaÃ§Ã£o booleana para criar uma seleÃ§Ã£o de nÃ£o-zeros
# dica: inverta o objeto bool_zero

bool_zero = (poi != 0)

poi_nao_zero = poi[bool_zero]

print(poi_nao_zero)
# iii) utilize a indexaÃ§Ã£o booleana para criar uma seleÃ§Ã£o de nÃ£o-zeros
# dica: inverta o objeto bool_zero
â€‹
bool_zero = (poi != 0)
â€‹
poi_nao_zero = poi[bool_zero]
â€‹
print(poi_nao_zero)
[3 3 6 2 4 5 4 4 2 3 3 2 8 2 3 3 3 4 4 2 6 6 3 4 3 5 2 1 3 2 2 3 2 4 4 5 7
 3 5 3 3 2 2 3 6 2 2 4 3 5 2 5 3 2 1 1 4 4 4 6 2 4 1 2 5 5 3 4 1 4 1 1 7 1
 2 1 3 7 4 4 6 1 3 4 2 5 4 5 5 3 4 6 8 2]
â€‹
